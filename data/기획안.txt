제약사가 재위탁계약관계를 시각적으로 확인하는 프로그램


최초 로그인시 제약사 인지 여부 확인
이메일과 사업자등록번호 입력

"사용자정보_등록현황_yyyymmdd.csv"

C열 Email
I열 사업자등록번호
F열 위탁-제약사/CSO구분명 = "제약사"

제약사라면
"위탁업체정보_등록현황_yyyymmdd.csv"

I열 위탁-사업자등록번호 에서 제약사 사업자등록번호를 찾아
Y열 수탁-사업자등록번호 를 추출하고, 아래 정보를 표기

"사용자정보_등록현황_yyyymmdd.csv"

H열 사업자명
I열 사업자등록번호
J열 대표자명
K열 사업장소재지
O열 CSO신고번호

재위탁업체들부터는

"재위탁통보정보_등록현황_yyyymmdd.csv"

F열 수신업체-사업자등록번호 가 로그인한 제약사인 것 중에서
G열 위탁업체-사업자등록번호 
H열 수탁업체-사업자등록번호

-------------------------------------------------------------------------

로그인한 사용자가 제약사라면,
제약사의 이메일 + 사업자등록번호 정보로 위탁업체(1차 수탁업체) 목록을 찾는 것은 맞아,

"위탁업체정보_등록현황_yyyymmdd.csv"
I열 위탁-사업자등록번호 에서 제약사 사업자등록번호를 찾아
Y열 수탁-사업자등록번호 를 추출하고

"사용자정보_등록현황_yyyymmdd.csv"에서 I열을 기준으로 아래 정보를 표기
H열 사업자명
I열 사업자등록번호
J열 대표자명
K열 사업장소재지
O열 CSO신고번호

그런데 그 다음 2차, 3차, 4차.. 위탁관계는 "위탁업체정보_등록현황_yyyymmdd.csv"로 찾는게 아니야.
실제로는 위탁(갑-을)관계가 있다고 해도, 제약사에 통보하지 않았으면 제약사는 알수 없게 하는게 맞아.

따라서 "재위탁통보정보_등록현황_yyyymmdd.csv" 을 참조해야 되.

F열 수신업체-사업자등록번호 가 로그인한 제약사와 일치하는 것들 중에서
현재 보여지고 있는 1차 수악업체의 사업자등록번호를
G열 위탁업체-사업자등록번호에서 찾아서, 
H열 수탁업체-사업자등록번호가 있는 업체들의 정보를

"사용자정보_등록현황_yyyymmdd.csv"에서 I열을 기준으로 아래 정보를 표기하면 돼.
H열 사업자명
I열 사업자등록번호
J열 대표자명
K열 사업장소재지
O열 CSO신고번호

그 다음 2차, 3차.. 재위탁도 같은 방식이야.


-------------------------------------------------------------------------


사업자등록번호를 문자열로 읽어오도록 명시해야 함
기존 strip() 처리도 그대로 유지하면 됨

표시 및 테이블 개선
사업자등록번호 기준 중복 제거: 한 번만 표기
No 항목 추가: 1, 2, 3... 순번
사업자등록번호 포맷: ###-##-##### 형식으로 표기
테이블 폰트 사이즈: 12px로 지정
하위(을) 업체 정보 펼치기
CSO 신고번호 뒤에 "재위탁업체" 항목 추가
해당 업체가 "갑"일 때 "을" 업체 수 표기
1개 이상일 때 "펼치기" 버튼 → 클릭 시 하위 업체 정보(동일 포맷) 표시
하위 업제 업체 No는 상위 No-1, 상위 No-2..




-----------------------------------------------------------------------------


데이터가 많아지거나 트리 구조로 재귀적으로 하위 업체를 계속 불러오다 보면
서버나 브라우저에서 "로드(지연, 느려짐)"가 발생할 수 있습니다.
아래는 코딩 없이 설명하는 성능 보완 방법입니다.
1. 최소한의 데이터만 불러오기 (지연 로딩, Lazy Loading)
한 번에 모든 하위 업체 정보를 다 불러오지 않고,
사용자가 "펼치기" 버튼을 눌렀을 때 그때그때 필요한 하위 정보만 서버에서 받아오는 방식입니다.
이미 이 방식을 쓰고 있다면,
하위 업체가 많을 때 한 번에 너무 많이 펼치지 않도록 제한을 둘 수 있습니다.
2. 페이지네이션 또는 "더보기" 버튼
하위 업체가 너무 많으면 한 번에 다 보여주지 않고,
10개씩, 20개씩만 보여주고 "더보기" 버튼을 눌렀을 때 추가로 불러오는 방식입니다.
3. 서버에서 데이터 가공/필터링
불필요한 데이터(예: 중복, 필요 없는 컬럼 등)는 서버에서 미리 걸러서
클라이언트로 보내는 데이터 양을 최소화합니다.
4. 브라우저 렌더링 최적화
너무 복잡한 HTML 테이블을 한 번에 그리지 않고,
필요한 부분만 동적으로 추가/수정하는 방식으로 렌더링 부담을 줄입니다.
5. 캐싱
이미 한 번 불러온 하위 업체 정보는
다시 펼칠 때 서버에 재요청하지 않고
클라이언트(브라우저)에서 캐싱해서 바로 보여줄 수 있습니다.
6. 서버/DB 성능 개선
데이터가 정말 많아지면,
CSV 대신 데이터베이스로 전환하거나
서버에서 pandas 대신 더 빠른 라이브러리(예: polars 등)를 사용할 수도 있습니다.
7. 최대 깊이 제한
트리의 깊이가 너무 깊어지면(예: 5차, 6차...)
일정 단계까지만 펼치게 제한을 둘 수도 있습니다.
정리:
한 번에 너무 많은 데이터를 불러오거나,
너무 깊은 트리를 한 번에 펼치지 않도록
"필요할 때만, 필요한 만큼" 데이터를 불러오고
이미 불러온 데이터는 캐싱해서 재사용하는 것이
가장 효과적인 성능 보완 방법입니다.


-----------------------------------------------------------------------

메뉴는 2개야.

1. 재위탁 관계 목록
2. 재위탁 관계도
   : 계약관계가 계층적으로 트리구조로만 되어 있지 않아서 그래.

제약사 밑에
재위탁업체가 A,B,C,D가 있다고 할때,
B가 또 A의 하위업체일수도 있고,
A의 하위 업체로 A-1이 있는데,
C가 A-1의 회원일 수도 있어.
서로 회원일 수도 있어.
C-D가 상호간에 갑이자 동시에 을일수도 있어.
제약사와 위탁업체들만 제외하고는 그물망처럼 얽혀있어.

이미지같은 관계를 표현할수 잇을까.
동그라미에 업체명만 나오고, 클릭하면 상세 정보가 나오고 하위 업체들이 나오고 했으면 좋겠어.
감에서 을로 가는 화살표가 있엇으면 좋겠어.
서로 회원이면 양방향 화살표야.

--------------------------------------------------------------------------------

1. 재위탁 관계 목록(테이블)과
2. 재위탁 관계도(네트워크)는 모두 같은 거를 구하는거야.

"내가(제약사) 위탁한 업체(biznum)가 나(제약사)에게 재위탁 사실을 통보한 하위 재위탁업체 수" 를 구하는거야.
실제 위탁관계를 구하는 것이 아니야.
즉, 내가(제약사) 위탁한 업체(biznum)가 위탁 관계를 10개 업체와 맺었다고 하여도,
내가 수신자로 되어있는 재위탁통보서 기준으로 8개 업체이면 나는 8개 업체의 정보만 봐야 하는거야!"

정확한 요구사항 요약
재위탁 관계 목록(테이블), 재위탁 관계도(네트워크)
둘 다
“내가(제약사, my_bn) 위탁한 업체(biznum)가
나(제약사)를 수신자로 하여
재위탁 사실을 통보한 하위 재위탁업체 수”
를 구하는 것입니다.
즉,
실제 위탁 계약 관계(위탁업체정보, 계약서 등)가 아니라
재위탁통보정보에서
수신업체-사업자등록번호 == my_bn
위탁업체-사업자등록번호 == biznum
인 행만 기준으로
하위 재위탁업체(수탁업체-사업자등록번호)의 수를 세는 것입니다.
내가(제약사) 수신자로 되어 있는 재위탁통보서만 기준입니다.
(즉, 내가 모르는 재위탁은 카운트하지 않음)
정리
관계 목록, 관계도 모두
subcontracts_df에서
수신업체-사업자등록번호 == my_bn
위탁업체-사업자등록번호 == biznum
인 행의
수탁업체-사업자등록번호의 개수만 세면 됩니다.
실제 위탁관계(위탁업체정보)와는 다름
(위탁업체정보에 10개가 있어도,
재위탁통보서에 8개만 있으면 8개만 보여야 함)


------------------------------------------------------------------------------------------------


일반적으로 제약사 입장에서 전체가 100개에서 200개 정도인데

20~30% 정도는 0 일거고 -> 원이 없는
20~30% 정도는 1~10 일거고 -> 점에서 작은 원
20~30% 정도는 10~50 일거고 -> 작은 원에서 중간 원
10% 정도는 100 이상일거야. 큰 원
제일 큰건 300이상이야.
10단위로 점점 켜져서 차이가 느껴졌으면  좋겠어.

그리고 재위탁업체가 있는 업체를 선택하면 선택된 업체에서 또 하위 업체들이 쭉 뻗어 나왔으면 좋겠어.
원은 같은 원리로.


--------------------------------------------------------------------------------


1. 아래까지 영역을 다 사용해주고

2. 업체명이 길면 (7글자 기준)
7글자 이상부터
띄어쓰기가 있으면 띄어쓰기 부분에서
​앞이나 뒤에 주식회사가 있으면 주식회사 부분에서
띄어쓰기가 없으면 그냥 중간에서 줄바꿈 해서 2줄로 표기해줘.
띄어쓰기에서 줄바꿈했으면 띄어쓰기를 없애줘.

예시)

더블유메디칼 주식회사

    더블유메디칼
   (공백)주식회사

이렇게 하지 말고!

    더블유메디칼
       주식회사

이렇게 하란 뜻이야.

주식회사 다즐
-> 주식회사
       다즐

스마일덕성팜주식회사
-> 스마일덕성팜
      주식회사

(주)코리아엠에스약품
->   (주)코리아
      엠에스약품


3. 노드들 사이에 여백이 너무 많아, 지금보다 촘촘하게 해줘.

4. 그리고 너무 딱딱한데, 노드들을 마우스로 살짝씩 움직이게 할수 없나?

5. 제약사는 가운데 크게 동그라미로 해줘, 업체들 300 사이즈 정도로


재위탁 관계 목록의 테이블 헤더를 단계별로 이미지처럼 해줘
5단계부턴 6,7,8.. 몇단계든 똑같이 가줘



index.html
460행

                // physics를 잠깐 켰다가 끄기
                networkInstance.setOptions({ physics: { enabled: true } });
                setTimeout(() => {
                    networkInstance.setOptions({ physics: { enabled: false } });
                }, 1200); // 1~2초 정도 후 physics 끄기




각 옵션의 의미
enabled
true: 물리 엔진(physics)이 동작하여 노드가 서로 밀고 당기며 움직임
false: 노드가 움직이지 않고, x, y 좌표에 고정됨
barnesHut
vis-network에서 대규모 네트워크의 빠른 물리 연산을 위한 기본 모델
barnesHut 내부 옵션
gravitationalConstant
노드 간의 인력/반발력의 크기와 방향을 결정
음수(예: -10000): 노드끼리 서로 밀어냄(퍼짐)
양수: 노드끼리 서로 끌어당김(모임)
절댓값이 클수록 힘이 강해짐
centralGravity
모든 노드를 중앙으로 끌어당기는 힘
값이 클수록 노드가 중앙에 더 모임(1.0~2.0 정도가 적당)
springLength
노드 간의 기본 거리(스프링의 자연 길이)
값이 클수록 노드 간 거리가 멀어짐(그래프가 더 퍼짐)
springConstant
스프링의 강도(탄성 계수)
값이 클수록 스프링이 더 뻣뻣해져서 노드 간 거리가 일정하게 유지됨
damping
감쇠 계수(0~1)
값이 클수록 노드의 움직임이 빨리 멈춤(0.1~0.5 정도가 적당)
avoidOverlap
노드끼리 겹침을 방지하는 힘
값이 클수록 노드가 더 멀리 떨어지려고 함(1.0~10.0 등으로 조정 가능)
조정 팁
노드가 너무 겹치면
avoidOverlap 값을 더 크게(예: 3~10)
springLength 값을 더 크게(예: 300~500)
gravitationalConstant의 절댓값을 더 크게(예: -20000)
노드가 너무 퍼지면
springLength 값을 줄이기
centralGravity 값을 키우기
움직임이 너무 오래가면
damping 값을 키우기(예: 0.4~0.6)

---------------------------------------------------------------

노드 정책

가운데 제약사가 나오고 주위에 위탁업체들 노드들이 나온다.
노드들이 중복되서 다른 노드를 가리지 않도록 반지름이 다른 원을 2개, 3개, 4개.. 전체 자식 노드 수에 따라 적절히 배분하고
각각 동일한 반지름을 갖지 않고 랜덤하게 거리를 조정한다.
노드 원의 크기는 위탁업체 수에 비례한다.

노드 선택시 해당 업체의 정보가 나오고, 자식 노드들이 펼쳐진다.
자식 노드들도 위와 같은 원리로
노드들이 중복되서 다른 노드를 가리지 않도록 반지름이 다른 원을 2개, 3개, 4개.. 전체 자식 노드 수에 따라 적절히 배분하고
각각 동일한 반지름을 갖지 않고 랜덤하게 거리를 조정한다.

중복이 안되는 상태였지만, 다른 노드가 펼쳐지며 자식 노드가 나오면 중복이 될 수 있다.
이때도 서로 최대한 중복이 안될 수 있도록 각자들 위치를 조정한다.

부모 노드를 움직이면 자식 노드들도 따라서 움직인다.
자식 노드들 중에서 다른 부모의 자식 상태로 현재 "펼쳐져 있는" 노드라면 적당히 중간 위치를 찾는다.
처음에 한 부모만 따라갔다가, 다른 부모를 선택해 그때 펼쳐지면 처음 부모와 다른 부모 사이로 적당한 위치를 찾는다.

자기 위의 부모 노드가 없어지면 같이 없어진다.
즉, A - B - C로 펼쳐진 상태에서 A를 닫으면 C도 같이 없어져야 한다.

---------------------------------------------------------------------------------------

1. 노드 배치(중복 방지, 원형 배치, 랜덤 반지름)
부모 노드(예: 제약사)를 중심으로,
자식 노드(위탁업체)들을 원형으로 배치합니다.
자식 노드가 많으면, 여러 개의 원(2, 3, 4...)에 분산해서 배치합니다.
각 원의 반지름은 자식 노드 수에 따라 자동으로 커집니다.
각 노드의 각도/거리(반지름)는 랜덤하게 약간씩 조정하여,
노드들이 겹치지 않고 자연스럽게 퍼지도록 합니다.
노드의 크기는 위탁업체 수(자식 수)에 비례하여 커집니다.

2. 노드 선택 시 동작
노드를 클릭하면 해당 업체의 상세 정보가 오른쪽에 표시됩니다.
동시에, 해당 노드의 자식 노드들이 펼쳐집니다.
자식 노드들도 위와 같은 원리(원형, 랜덤 반지름, 중복 방지)로 배치합니다.

3. 중복 방지 및 동적 위치 조정
이미 펼쳐진 다른 노드의 자식들과 겹칠 수 있으므로,
새로 펼쳐지는 자식 노드의 위치를 기존 노드들과 겹치지 않게 조정해야 합니다.
필요하다면, 충돌 감지 후 위치를 재조정하는 로직을 추가합니다.

4. 부모-자식 동기화(드래그/이동)
부모 노드를 드래그하면,
자식 노드들도 함께 이동합니다.
자식 노드가 여러 부모를 가질 경우,
펼쳐진 부모들 사이의 중간 위치로 이동합니다.
즉, 부모가 여러 개 펼쳐져 있으면,
자식 노드는 부모들의 평균 위치로 이동합니다.

5. 노드 닫기(접기) 시 동작
부모 노드를 닫으면,
해당 부모의 모든 자식 노드와 그 하위 노드들까지 재귀적으로 모두 사라집니다.
즉, A - B - C로 펼쳐진 상태에서 A를 닫으면,
B, C 모두 같이 사라집니다.

구현 전략

1. 노드 위치 계산 함수
각 부모 노드의 위치와 자식 노드 수를 받아,
자식 노드들의 (x, y) 좌표를 원형으로 계산
각도는 360 / 자식수로 나누고,
반지름은 기본값 + (자식수 * 계수) + 랜덤값으로 조정

2. 노드 크기 계산
자식 수에 따라 size = 기본값 + (자식수 * 계수)로 설정

3. 충돌 방지
새로 배치할 때, 기존 노드들과의 거리를 체크해서
일정 거리 이하로 겹치지 않게 위치를 미세 조정

4. 드래그/이동 동기화
부모 노드가 이동하면,
자식 노드들의 위치도 같이 이동
자식 노드가 여러 부모를 가질 경우,
펼쳐진 부모들의 평균 위치로 이동

5. 노드 트리 관리
각 노드의 부모/자식 관계를 트리 구조로 관리
펼쳐진 상태, 닫힌 상태, 부모가 사라질 때 자식도 재귀적으로 삭제

---------------------------------------------------------------------------------------

노드를 선택하면 업체 정보는 나와.
자식 노드들이 펼쳐지는지는 잘 모르겠어.
그런데 배치가 모두 이상하게 돼.
자식 노드를 펼쳐서 새로운 노드가 등장하거나, 기존 노드를 움직이거나 해서 재배치가 필요한 경우는 영향을 미치는 노드들에 한해서야.
다른 노드들은 그대로 있고, 위 상황으로 중복이 발생하는 영향을 받는 노드들만 움직이면 돼.
갑자기 확 움직이지 말고 부드럽게 물리법칙 적용해 위치가 변경됬으면 좋겠어.

---------------------------------------------------------------------------------------

1. 문제 요약
노드 클릭 시 상세 정보는 잘 나오지만,
자식 노드가 펼쳐질 때,
전체 네트워크가 갑자기 확 움직이거나, 배치가 부자연스럽다.
영향받는 노드들만 부드럽게(physics 적용) 재배치하고,
나머지 노드는 그대로 두고 싶다.

 2. 해결 전략
1) 영향받는 노드만 physics 적용
자식 노드가 펼쳐질 때:
새로 등장하는 자식 노드와 그 부모(혹은 인접 노드)만 physics를 켜서 자연스럽게 배치
나머지 노드:
위치를 고정(physics off)하여 움직이지 않게 함

2) vis-network의 physics 옵션 활용
vis-network는 각 노드별로 physics를 on/off 할 수 있습니다.
data.nodes.update({id: ..., physics: true/false})로 개별 노드의 물리 적용 여부를 조정할 수 있습니다.

3) 배치 알고리즘
펼쳐지는 자식 노드들만 원형 배치의 초기 위치로 배치
physics를 잠깐 켜서 자연스럽게 퍼지게 한 뒤,
다시 physics를 꺼서 위치를 고정

---------------------------------------------------------------------------------------







python app.py